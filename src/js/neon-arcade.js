/**
 * Neon Arcade JavaScript
 * Interactive functionality for the cyberpunk arcade experience
 */

// Game data configuration
const gameData = {
    'adventure-rpg': {
        title: 'Adventure RPG',
        description: 'Simple mechanics for building an RPG framework. TypeScript is used in this project.',
        url: 'https://jaxsbr.github.io/AdventureRPG/',
        image: 'img/adventurerpg.png',
        deviceType: 'desktop' // Requires keyboard input
    },
    'ai-behavior': {
        title: 'AI Behavior',
        description: 'This AI behavior demo contains real-time strategy mechanics. Map scrolling, tile grid rendering and custom bounds collision. Bots are generated by CPU entities that find and gather resources.',
        url: 'https://jaxsbr.github.io/AIBehavior/',
        image: 'img/aiBehavior.png',
        deviceType: 'desktop' // Requires mouse and keyboard
    },
    'image-shuffle': {
        title: 'Image Shuffle',
        description: 'Simple puzzle game. Reshuffle the image back to its original state.',
        url: 'https://jaxsbr.github.io/ImageShuffle/',
        image: 'img/shuffle.png',
        deviceType: 'both' // Touch-friendly and works on desktop
    },
    'robo-war': {
        title: 'Robo War',
        description: 'WASD movement with mouse aim and shoot mechanics.',
        url: 'https://jaxsbr.github.io/RoboWar/',
        image: 'img/robot.png',
        deviceType: 'desktop' // Requires WASD + mouse
    },
    'platformer': {
        title: 'Platformer',
        description: 'Platformer example with custom physics, collision detection and content loading.',
        url: 'https://jaxsbr.github.io/Platformer/',
        image: 'img/platformer.png',
        deviceType: 'desktop' // Requires keyboard input
    },
    'cutedefense': {
        title: 'CuteDefense',
        description: 'Tower defense game with cute graphics and strategic gameplay.',
        url: 'https://jaxsbr.github.io/CuteDefense/',
        image: 'img/cutedefense.png',
        deviceType: 'both' // Touch-friendly and works on desktop
    },
    'prototype1': {
        title: 'Prototype1',
        description: 'Kids shapes prototype game for learning and fun.',
        url: 'https://jaxsbr.github.io/Kids-Game-Prototype-1/',
        image: 'img/prototype1.png',
        deviceType: 'both' // Touch-friendly and works on desktop
    }
};

// DOM elements
let modal, modalTitle, modalDescription, modalImage, playLink, modalDeviceLabel;
let closeModalButtons;

// Initialize the arcade when DOM is loaded
document.addEventListener('DOMContentLoaded', function () {
    initializeArcade();
});

/**
 * Initialize all arcade functionality
 */
function initializeArcade() {
    // Get DOM elements
    modal = document.getElementById('game-modal');
    modalTitle = document.getElementById('modal-title');
    modalDescription = document.getElementById('modal-description');
    modalImage = document.getElementById('modal-image');
    playLink = document.getElementById('play-link');
    modalDeviceLabel = document.getElementById('modal-device-label');
    closeModalButtons = document.querySelectorAll('.close-modal');

    // Set up event listeners
    setupCabinetListeners();
    setupModalListeners();
    setupNeonEffects();
    setupKeyboardNavigation();
    setupNavigation();
    setupFiltering();
    setupSmoothScrolling();
}

/**
 * Set up event listeners for arcade cabinets
 */
function setupCabinetListeners() {
    const cabinets = document.querySelectorAll('.arcade-cabinet');

    cabinets.forEach(cabinet => {
        // Add click event listener for cabinet (opens modal)
        cabinet.addEventListener('click', function (e) {
            // Don't trigger if clicking on the play button
            if (e.target.classList.contains('play-button')) {
                return;
            }
            const gameId = this.getAttribute('data-game');
            openGameModal(gameId);
        });

        // Add click event listener for play buttons (direct launch)
        const playButton = cabinet.querySelector('.play-button');
        if (playButton) {
            playButton.addEventListener('click', function (e) {
                e.stopPropagation(); // Prevent cabinet click
                const gameId = cabinet.getAttribute('data-game');
                launchGame(gameId);
            });
        }

        // Add keyboard support
        cabinet.addEventListener('keydown', function (e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                const gameId = this.getAttribute('data-game');
                openGameModal(gameId);
            }
        });

        // Make cabinets focusable
        cabinet.setAttribute('tabindex', '0');
        cabinet.setAttribute('role', 'button');
        cabinet.setAttribute('aria-label', `Play ${gameData[cabinet.getAttribute('data-game')]?.title || 'game'}`);
    });
}

/**
 * Set up modal event listeners
 */
function setupModalListeners() {
    // Close modal buttons
    closeModalButtons.forEach(button => {
        button.addEventListener('click', closeGameModal);
    });

    // Modal play button click handler
    if (playLink) {
        playLink.addEventListener('click', function (e) {
            e.preventDefault(); // Prevent default link behavior
            const gameId = this.getAttribute('data-game-id');
            if (gameId) {
                launchGame(gameId);
                closeGameModal(); // Close modal after launching
            } else {
                // Fallback: open the href directly
                window.open(this.href, '_blank');
                closeGameModal();
            }
        });
    }

    // Close modal when clicking outside
    modal.addEventListener('click', function (e) {
        if (e.target === modal) {
            closeGameModal();
        }
    });

    // Close modal with Escape key
    document.addEventListener('keydown', function (e) {
        if (e.key === 'Escape' && modal.style.display === 'block') {
            closeGameModal();
        }
    });
}

/**
 * Set up neon effects and animations
 */
function setupNeonEffects() {
    // Add random neon color variations to titles
    const titles = document.querySelectorAll('.neon-title, .section-title');
    const neonColors = ['neon-glow', 'neon-glow-pink', 'neon-glow-green', 'neon-glow-purple'];
    const advancedEffects = ['neon-pulse-advanced', 'neon-flicker', 'neon-rainbow'];

    titles.forEach((title, index) => {
        const randomColor = neonColors[Math.floor(Math.random() * neonColors.length)];
        title.classList.add(randomColor);

        // Add advanced effects to some titles
        if (index % 3 === 0) {
            const randomAdvanced = advancedEffects[Math.floor(Math.random() * advancedEffects.length)];
            title.classList.add(randomAdvanced);
        }
    });

    // Add subtle animations to cabinets
    const cabinets = document.querySelectorAll('.arcade-cabinet');
    cabinets.forEach((cabinet, index) => {
        // Stagger the animation delays
        cabinet.style.animationDelay = `${index * 0.1}s`;
        cabinet.classList.add('cabinet-idle-animation');

        // Add random advanced effects to some cabinets
        if (index % 2 === 0) {
            cabinet.classList.add('cabinet-idle-glow');
        }
    });

    // Initialize cursor trail effect
    setupCursorTrail();

    // Initialize matrix particles
    setupMatrixParticles();
}

/**
 * Set up keyboard navigation
 */
function setupKeyboardNavigation() {
    // Add focus management for better accessibility
    document.addEventListener('keydown', function (e) {
        if (e.key === 'Tab') {
            // Add focus indicators
            const focusedElement = document.activeElement;
            if (focusedElement.classList.contains('arcade-cabinet')) {
                focusedElement.style.transform = 'translateY(-5px) scale(1.02)';
            }
        }
    });

    // Remove focus effects when element loses focus
    document.addEventListener('focusout', function (e) {
        if (e.target.classList.contains('arcade-cabinet')) {
            e.target.style.transform = '';
        }
    });
}

/**
 * Open game modal with game information
 * @param {string} gameId - The ID of the game to display
 */
function openGameModal(gameId) {
    const game = gameData[gameId];

    if (!game) {
        console.error('Game not found:', gameId);
        return;
    }

    // Update modal content
    modalTitle.textContent = game.title;
    modalDescription.textContent = game.description;
    modalImage.src = game.image;
    modalImage.alt = `${game.title} preview`;
    playLink.href = game.url;
    playLink.setAttribute('data-game-id', gameId); // Set game ID for modal play button

    // Update device label
    if (modalDeviceLabel && game.deviceType) {
        let labelText = '';
        switch (game.deviceType) {
            case 'mobile':
                labelText = 'Mobile';
                break;
            case 'desktop':
                labelText = 'Desktop';
                break;
            case 'both':
                labelText = 'Any Device';
                break;
            default:
                labelText = 'Desktop';
        }
        modalDeviceLabel.textContent = labelText;
        modalDeviceLabel.className = `device-label ${game.deviceType}`;
    }

    // Show modal
    modal.style.display = 'block';
    document.body.style.overflow = 'hidden';

    // Focus management
    const firstFocusable = modal.querySelector('button, a');
    if (firstFocusable) {
        firstFocusable.focus();
    }

    // Add entrance animation
    modal.classList.add('modal-enter');
}

/**
 * Close the game modal
 */
function closeGameModal() {
    modal.style.display = 'none';
    document.body.style.overflow = '';
    modal.classList.remove('modal-enter');
}

/**
 * Launch a game directly
 * @param {string} gameId - The ID of the game to launch
 */
function launchGame(gameId) {
    const game = gameData[gameId];

    if (!game) {
        console.error('Game not found:', gameId);
        return;
    }

    // Show loading state
    showGameLoadingState(game.title);

    // Launch the game in a new tab after a short delay for effect
    setTimeout(() => {
        window.open(game.url, '_blank');
        hideGameLoadingState();
    }, 500);
}

/**
 * Show game loading state
 * @param {string} gameTitle - The title of the game being loaded
 */
function showGameLoadingState(gameTitle) {
    const loadingOverlay = document.createElement('div');
    loadingOverlay.id = 'game-loading-overlay';
    loadingOverlay.innerHTML = `
        <div class="game-loading-content">
            <div class="game-loading-spinner"></div>
            <p class="game-loading-text">Launching ${gameTitle}...</p>
            <p class="game-loading-subtitle">Opening in new tab</p>
        </div>
    `;

    const style = document.createElement('style');
    style.textContent = `
        #game-loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
        }
        
        .game-loading-content {
            text-align: center;
            color: var(--neon-blue);
            padding: var(--spacing-lg);
            border: 2px solid var(--neon-blue);
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.8);
            box-shadow: var(--neon-shadow-blue);
        }
        
        .game-loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--neon-blue);
            border-top: 4px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        .game-loading-text {
            font-family: var(--font-primary);
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: var(--spacing-xs);
            text-shadow: var(--neon-shadow-blue);
        }
        
        .game-loading-subtitle {
            font-family: var(--font-secondary);
            font-size: 1rem;
            color: var(--neon-gray-light);
            margin: 0;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    `;

    document.head.appendChild(style);
    document.body.appendChild(loadingOverlay);
}

/**
 * Hide game loading state
 */
function hideGameLoadingState() {
    const loadingOverlay = document.getElementById('game-loading-overlay');
    if (loadingOverlay) {
        loadingOverlay.style.animation = 'fadeOut 0.3s ease-out';
        setTimeout(() => {
            loadingOverlay.remove();
        }, 300);
    }
}

/**
 * Add CSS animations dynamically
 */
function addDynamicStyles() {
    const style = document.createElement('style');
    style.textContent = `
    .cabinet-idle-animation {
      animation: cabinet-idle 4s ease-in-out infinite alternate;
    }
    
    @keyframes cabinet-idle {
      0% {
        filter: brightness(1);
      }
      100% {
        filter: brightness(1.1);
      }
    }
    
    .modal-enter .modal-content {
      animation: modal-enter 0.3s ease-out;
    }
    
    @keyframes modal-enter {
      from {
        opacity: 0;
        transform: scale(0.8) translateY(-50px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }
    
    /* Enhanced hover effects */
    .arcade-cabinet:hover .cabinet-screen {
      animation: cabinet-glow 0.6s ease-in-out infinite alternate;
    }
    
    @keyframes cabinet-glow {
      from {
        box-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue), 0 0 15px var(--neon-blue);
      }
      to {
        box-shadow: 0 0 10px var(--neon-pink), 0 0 20px var(--neon-pink), 0 0 30px var(--neon-pink);
      }
    }
  `;
    document.head.appendChild(style);
}

// Add dynamic styles when script loads
addDynamicStyles();

// Performance optimization: Debounce scroll events
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Add scroll-based effects with parallax
const handleScroll = debounce(() => {
    const scrollTop = window.pageYOffset;
    const header = document.querySelector('.neon-header');

    if (header) {
        const headerHeight = header.offsetHeight;
        const opacity = Math.max(0, 1 - (scrollTop / headerHeight));
        header.style.opacity = opacity;
    }

    // Parallax effects for Tron grids
    const tronGrids = document.querySelectorAll('.tron-grid-advanced, .tron-grid-pulse');
    tronGrids.forEach((grid, index) => {
        const speed = 0.5 + (index * 0.2); // Different speeds for different layers
        const yPos = -(scrollTop * speed);
        grid.style.transform = `translateY(${yPos}px)`;
    });

    // Parallax for matrix particles
    const matrixParticles = document.querySelector('.matrix-particles');
    if (matrixParticles) {
        const yPos = -(scrollTop * 0.3);
        matrixParticles.style.transform = `translateY(${yPos}px)`;
    }

    // Parallax for regular grid
    const regularGrid = document.querySelector('.grid-background');
    if (regularGrid) {
        const yPos = -(scrollTop * 0.8);
        regularGrid.style.transform = `translateY(${yPos}px)`;
    }
}, 10);

window.addEventListener('scroll', handleScroll);

// Add loading state management
function showLoadingState() {
    const loadingOverlay = document.createElement('div');
    loadingOverlay.id = 'loading-overlay';
    loadingOverlay.innerHTML = `
    <div class="loading-content">
      <div class="loading-spinner"></div>
      <p class="loading-text">Loading Arcade...</p>
    </div>
  `;

    const style = document.createElement('style');
    style.textContent = `
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--neon-black);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    
    .loading-content {
      text-align: center;
      color: var(--neon-blue);
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 3px solid var(--neon-blue);
      border-top: 3px solid transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .loading-text {
      font-family: var(--font-primary);
      font-size: 1.2rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
  `;

    document.head.appendChild(style);
    document.body.appendChild(loadingOverlay);
}

function hideLoadingState() {
    const loadingOverlay = document.getElementById('loading-overlay');
    if (loadingOverlay) {
        loadingOverlay.remove();
    }
}

// Show loading state initially, hide when everything is ready
showLoadingState();

// Hide loading state when everything is loaded
window.addEventListener('load', () => {
    setTimeout(hideLoadingState, 1000); // Show loading for at least 1 second for effect
});

/**
 * Set up navigation functionality
 */
function setupNavigation() {
    const navToggle = document.querySelector('.nav-toggle');
    const navMenu = document.querySelector('.nav-menu');
    const navLinks = document.querySelectorAll('.nav-link');

    // Mobile menu toggle
    if (navToggle && navMenu) {
        navToggle.addEventListener('click', function () {
            navToggle.classList.toggle('active');
            navMenu.classList.toggle('active');
        });

        // Close menu when clicking on a link
        navLinks.forEach(link => {
            link.addEventListener('click', function () {
                navToggle.classList.remove('active');
                navMenu.classList.remove('active');
            });
        });

        // Close menu when clicking outside
        document.addEventListener('click', function (e) {
            if (!navToggle.contains(e.target) && !navMenu.contains(e.target)) {
                navToggle.classList.remove('active');
                navMenu.classList.remove('active');
            }
        });
    }

    // Active navigation highlighting
    window.addEventListener('scroll', debounce(() => {
        const sections = document.querySelectorAll('section[id]');
        const scrollPos = window.scrollY + 100;

        sections.forEach(section => {
            const sectionTop = section.offsetTop;
            const sectionHeight = section.offsetHeight;
            const sectionId = section.getAttribute('id');
            const navLink = document.querySelector(`.nav-link[href="#${sectionId}"]`);

            if (scrollPos >= sectionTop && scrollPos < sectionTop + sectionHeight) {
                navLinks.forEach(link => link.classList.remove('active'));
                if (navLink) navLink.classList.add('active');
            }
        });
    }, 10));
}

/**
 * Set up game filtering functionality
 */
function setupFiltering() {
    const filterButtons = document.querySelectorAll('.filter-btn');
    const cabinets = document.querySelectorAll('.arcade-cabinet');
    const grid = document.querySelector('.arcade-grid');

    filterButtons.forEach(button => {
        button.addEventListener('click', function () {
            const filter = this.getAttribute('data-filter');

            // Update active button
            filterButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');

            // Add filtered class to grid
            grid.classList.add('filtered');

            // Filter cabinets and reorganize
            let visibleCount = 0;
            cabinets.forEach(cabinet => {
                const category = cabinet.getAttribute('data-category');

                if (filter === 'all' || category === filter) {
                    cabinet.classList.remove('hidden');
                    cabinet.classList.add('visible');
                    visibleCount++;
                } else {
                    cabinet.classList.add('hidden');
                    cabinet.classList.remove('visible');
                }
            });

            // Update grid layout based on visible games
            if (visibleCount === 0) {
                grid.style.gridTemplateColumns = '1fr';
                grid.style.justifyContent = 'center';
            } else if (visibleCount === 1) {
                grid.style.gridTemplateColumns = '1fr';
                grid.style.justifyContent = 'center';
            } else if (visibleCount === 2) {
                grid.style.gridTemplateColumns = 'repeat(2, 1fr)';
                grid.style.justifyContent = 'center';
            } else {
                grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(300px, 1fr))';
                grid.style.justifyContent = 'start';
            }

            // Animate grid layout
            grid.style.opacity = '0.5';
            setTimeout(() => {
                grid.style.opacity = '1';
            }, 150);
        });
    });
}

/**
 * Set up smooth scrolling for navigation links
 */
function setupSmoothScrolling() {
    const navLinks = document.querySelectorAll('a[href^="#"]');
    const ctaButtons = document.querySelectorAll('.neon-button[href^="#"]');

    [...navLinks, ...ctaButtons].forEach(link => {
        link.addEventListener('click', function (e) {
            e.preventDefault();

            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);

            if (targetElement) {
                const headerHeight = document.querySelector('.neon-nav')?.offsetHeight || 0;
                const targetPosition = targetElement.offsetTop - headerHeight - 20;

                window.scrollTo({
                    top: targetPosition,
                    behavior: 'smooth'
                });
            }
        });
    });
}

/**
 * Add enhanced particle effects
 */
function createParticles() {
    const particlesContainer = document.querySelector('.particles-background');
    if (!particlesContainer) return;

    // Create multiple floating particles
    for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'floating-particle';
        particle.style.cssText = `
            position: absolute;
            width: ${Math.random() * 3 + 1}px;
            height: ${Math.random() * 3 + 1}px;
            background: var(--neon-blue);
            border-radius: 50%;
            left: ${Math.random() * 100}%;
            top: ${Math.random() * 100}%;
            opacity: ${Math.random() * 0.5 + 0.3};
            animation: float-particle ${Math.random() * 10 + 5}s ease-in-out infinite;
            animation-delay: ${Math.random() * 5}s;
        `;
        particlesContainer.appendChild(particle);
    }

    // Add particle animation CSS
    const style = document.createElement('style');
    style.textContent = `
        @keyframes float-particle {
            0%, 100% {
                transform: translateY(0px) translateX(0px) scale(1);
                opacity: 0.3;
            }
            25% {
                transform: translateY(-20px) translateX(10px) scale(1.2);
                opacity: 0.8;
            }
            50% {
                transform: translateY(-10px) translateX(-5px) scale(0.8);
                opacity: 0.5;
            }
            75% {
                transform: translateY(-30px) translateX(15px) scale(1.1);
                opacity: 0.7;
            }
        }
    `;
    document.head.appendChild(style);
}

// Initialize particles after DOM is loaded
document.addEventListener('DOMContentLoaded', function () {
    setTimeout(createParticles, 1000);
});

/**
 * Set up cursor trail effect
 */
function setupCursorTrail() {
    let mouseX = 0;
    let mouseY = 0;
    let trailElements = [];

    document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;

        // Create trail element
        const trail = document.createElement('div');
        trail.className = 'cursor-trail';
        trail.style.left = mouseX + 'px';
        trail.style.top = mouseY + 'px';

        // Randomize trail color
        const colors = ['var(--neon-blue)', 'var(--neon-pink)', 'var(--neon-green)', 'var(--neon-purple)'];
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        trail.style.background = `radial-gradient(circle, ${randomColor}, transparent)`;

        document.body.appendChild(trail);
        trailElements.push(trail);

        // Remove trail after animation
        setTimeout(() => {
            if (trail.parentNode) {
                trail.parentNode.removeChild(trail);
            }
            trailElements = trailElements.filter(el => el !== trail);
        }, 500);

        // Limit number of trail elements
        if (trailElements.length > 10) {
            const oldTrail = trailElements.shift();
            if (oldTrail && oldTrail.parentNode) {
                oldTrail.parentNode.removeChild(oldTrail);
            }
        }
    });
}

/**
 * Set up matrix-style particle background
 */
function setupMatrixParticles() {
    const matrixContainer = document.querySelector('.matrix-particles');
    if (!matrixContainer) return;

    const characters = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
    const numbers = '0123456789';
    const allChars = characters + numbers;

    function createMatrixParticle() {
        const particle = document.createElement('div');
        particle.className = 'matrix-particle';
        particle.textContent = allChars[Math.floor(Math.random() * allChars.length)];

        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDuration = (Math.random() * 5 + 5) + 's';
        particle.style.animationDelay = Math.random() * 2 + 's';

        // Random color
        const colors = ['var(--neon-green)', 'var(--neon-blue)', 'var(--neon-pink)'];
        particle.style.color = colors[Math.floor(Math.random() * colors.length)];

        matrixContainer.appendChild(particle);

        // Remove particle after animation
        setTimeout(() => {
            if (particle.parentNode) {
                particle.parentNode.removeChild(particle);
            }
        }, 10000);
    }

    // Create particles periodically
    setInterval(createMatrixParticle, 200);

    // Create initial particles
    for (let i = 0; i < 20; i++) {
        setTimeout(createMatrixParticle, i * 100);
    }
}

/**
 * Enhanced cabinet interactions
 */
function setupEnhancedCabinetInteractions() {
    const cabinets = document.querySelectorAll('.arcade-cabinet');
    let selectedCabinet = null;

    cabinets.forEach(cabinet => {
        // Add selection state
        cabinet.addEventListener('click', function (e) {
            if (e.target.classList.contains('play-button')) {
                return; // Don't select if clicking play button
            }

            // Remove previous selection
            if (selectedCabinet) {
                selectedCabinet.classList.remove('selected');
                selectedCabinet.classList.remove('cabinet-selected');
            }

            // Add selection to current cabinet
            this.classList.add('selected');
            this.classList.add('cabinet-selected');
            selectedCabinet = this;

            // Remove selection after animation
            setTimeout(() => {
                this.classList.remove('cabinet-selected');
            }, 500);
        });

        // Add loading state for play buttons
        const playButton = cabinet.querySelector('.play-button');
        if (playButton) {
            playButton.addEventListener('click', function () {
                const cabinet = this.closest('.arcade-cabinet');
                cabinet.classList.add('cabinet-loading');

                // Remove loading state after game launch
                setTimeout(() => {
                    cabinet.classList.remove('cabinet-loading');
                }, 1000);
            });
        }
    });
}

// Initialize enhanced interactions
document.addEventListener('DOMContentLoaded', function () {
    setTimeout(setupEnhancedCabinetInteractions, 1000);
    setTimeout(setupSoundEffects, 2000);
});

/**
 * Set up optional arcade sound effects
 */
function setupSoundEffects() {
    // Check if user prefers reduced motion or has disabled audio
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        return; // Skip sound effects for accessibility
    }

    let audioContext = null;
    let soundEnabled = false;

    // Initialize Web Audio API
    function initAudio() {
        if (!audioContext) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                soundEnabled = true;
                console.log('Arcade sound effects enabled');
            } catch (e) {
                console.log('Web Audio API not supported');
                return;
            }
        }
    }

    // Create sound effects using Web Audio API
    function createBeep(frequency = 800, duration = 0.1, type = 'sine') {
        if (!soundEnabled || !audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }

    function createArcadeClick() {
        createBeep(1000, 0.05, 'square');
    }

    function createArcadeHover() {
        createBeep(1200, 0.08, 'sine');
    }

    function createGameLaunch() {
        // Create a sequence of beeps for game launch
        createBeep(800, 0.1, 'sine');
        setTimeout(() => createBeep(1000, 0.1, 'sine'), 100);
        setTimeout(() => createBeep(1200, 0.1, 'sine'), 200);
    }

    function createModalOpen() {
        createBeep(600, 0.15, 'triangle');
    }

    function createModalClose() {
        createBeep(400, 0.15, 'triangle');
    }

    // Add sound effects to interactions
    function addSoundToElements() {
        // Cabinet hover sounds
        const cabinets = document.querySelectorAll('.arcade-cabinet');
        cabinets.forEach(cabinet => {
            cabinet.addEventListener('mouseenter', () => {
                if (soundEnabled) createArcadeHover();
            });
        });

        // Play button click sounds
        const playButtons = document.querySelectorAll('.play-button');
        playButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (soundEnabled) createGameLaunch();
            });
        });

        // Filter button sounds
        const filterButtons = document.querySelectorAll('.filter-btn');
        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (soundEnabled) createArcadeClick();
            });
        });

        // Navigation link sounds
        const navLinks = document.querySelectorAll('.nav-link');
        navLinks.forEach(link => {
            link.addEventListener('click', () => {
                if (soundEnabled) createArcadeClick();
            });
        });
    }

    // Add sound to modal interactions
    function addModalSounds() {
        const modal = document.getElementById('game-modal');
        if (modal) {
            // Override modal functions to add sounds
            const originalOpenModal = window.NeonArcade.openGameModal;
            const originalCloseModal = window.NeonArcade.closeGameModal;

            window.NeonArcade.openGameModal = function (gameId) {
                if (soundEnabled) createModalOpen();
                return originalOpenModal.call(this, gameId);
            };

            window.NeonArcade.closeGameModal = function () {
                if (soundEnabled) createModalClose();
                return originalCloseModal.call(this);
            };
        }
    }

    // Create sound toggle button
    function createSoundToggle() {
        const soundToggle = document.createElement('button');
        soundToggle.id = 'sound-toggle';
        soundToggle.innerHTML = '🔊';
        soundToggle.title = 'Toggle Sound Effects';
        soundToggle.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid var(--neon-blue);
            background: rgba(0, 0, 0, 0.8);
            color: var(--neon-blue);
            font-size: 20px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
        `;

        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggle.innerHTML = soundEnabled ? '🔊' : '🔇';
            soundToggle.style.color = soundEnabled ? 'var(--neon-blue)' : 'var(--neon-gray)';
            soundToggle.style.borderColor = soundEnabled ? 'var(--neon-blue)' : 'var(--neon-gray)';

            if (soundEnabled && !audioContext) {
                initAudio();
            }
        });

        soundToggle.addEventListener('mouseenter', () => {
            soundToggle.style.boxShadow = '0 0 20px var(--neon-blue)';
        });

        soundToggle.addEventListener('mouseleave', () => {
            soundToggle.style.boxShadow = 'none';
        });

        document.body.appendChild(soundToggle);
    }

    // Initialize everything
    createSoundToggle();

    // Initialize audio on first user interaction
    document.addEventListener('click', () => {
        if (!audioContext) {
            initAudio();
            addSoundToElements();
            addModalSounds();
        }
    }, { once: true });
}

// Export functions for potential external use
window.NeonArcade = {
    openGameModal,
    closeGameModal,
    launchGame,
    gameData,
    setupFiltering,
    setupNavigation,
    setupCursorTrail,
    setupMatrixParticles,
    setupEnhancedCabinetInteractions,
    setupSoundEffects
};

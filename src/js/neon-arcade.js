/**
 * Neon Arcade JavaScript
 * Interactive functionality for the cyberpunk arcade experience
 */

// Game data configuration
const gameData = {
    'adventure-rpg': {
        title: 'Adventure RPG',
        description: 'Simple mechanics for building an RPG framework. TypeScript is used in this project.',
        url: 'https://jaxsbr.github.io/AdventureRPG/',
        image: 'img/adventurerpg.png',
        deviceType: 'desktop' // Requires keyboard input
    },
    'ai-behavior': {
        title: 'AI Behavior',
        description: 'This AI behavior demo contains real-time strategy mechanics. Map scrolling, tile grid rendering and custom bounds collision. Bots are generated by CPU entities that find and gather resources.',
        url: 'https://jaxsbr.github.io/AIBehavior/',
        image: 'img/aiBehavior.png',
        deviceType: 'desktop' // Requires mouse and keyboard
    },
    'image-shuffle': {
        title: 'Image Shuffle',
        description: 'Simple puzzle game. Reshuffle the image back to its original state.',
        url: 'https://jaxsbr.github.io/ImageShuffle/',
        image: 'img/shuffle.png',
        deviceType: 'both' // Touch-friendly and works on desktop
    },
    'robo-war': {
        title: 'Robo War',
        description: 'WASD movement with mouse aim and shoot mechanics.',
        url: 'https://jaxsbr.github.io/RoboWar/',
        image: 'img/robot.png',
        deviceType: 'desktop' // Requires WASD + mouse
    },
    'platformer': {
        title: 'Platformer',
        description: 'Platformer example with custom physics, collision detection and content loading.',
        url: 'https://jaxsbr.github.io/Platformer/',
        image: 'img/platformer.png',
        deviceType: 'desktop' // Requires keyboard input
    },
    'cutedefense': {
        title: 'CuteDefense',
        description: 'Tower defense game with cute graphics and strategic gameplay.',
        url: 'https://jaxsbr.github.io/CuteDefense/',
        image: 'img/cutedefense.png',
        deviceType: 'both' // Touch-friendly and works on desktop
    },
    'prototype1': {
        title: 'Prototype1',
        description: 'Kids shapes prototype game for learning and fun.',
        url: 'https://jaxsbr.github.io/Kids-Game-Prototype-1/',
        image: 'img/prototype1.png',
        deviceType: 'both' // Touch-friendly and works on desktop
    },
    'jank': {
        title: 'Jank',
        description: 'Arena defense game where you control a powerful stationary core. Defend against enemy waves with energy arcs and pulses over a hexagonal hive.',
        url: 'https://jaxsbr.github.io/Jank/',
        image: 'img/jank.png',
        deviceType: 'both' // Touch-friendly and works on desktop
    }
};

// DOM elements
let modal, modalTitle, modalDescription, modalImage, playLink, modalDeviceLabel;
let closeModalButtons;

// Initialize the arcade when DOM is loaded
document.addEventListener('DOMContentLoaded', function () {
    initializeArcade();
});

/**
 * Initialize all arcade functionality
 */
function initializeArcade() {
    // Get DOM elements
    modal = document.getElementById('game-modal');
    modalTitle = document.getElementById('modal-title');
    modalDescription = document.getElementById('modal-description');
    modalImage = document.getElementById('modal-image');
    playLink = document.getElementById('play-link');
    modalDeviceLabel = document.getElementById('modal-device-label');
    closeModalButtons = document.querySelectorAll('.close-modal');

    // Set up event listeners
    setupCabinetListeners();
    setupModalListeners();
    setupNeonEffects();
    setupKeyboardNavigation();
    setupNavigation();
    setupFiltering();
    setupSmoothScrolling();
}

/**
 * Set up event listeners for arcade cabinets
 */
function setupCabinetListeners() {
    const cabinets = document.querySelectorAll('.arcade-cabinet');

    cabinets.forEach(cabinet => {
        // Add click event listener for cabinet (opens modal)
        cabinet.addEventListener('click', function (e) {
            // Don't trigger if clicking on the play button
            if (e.target.classList.contains('play-button')) {
                return;
            }
            const gameId = this.getAttribute('data-game');
            openGameModal(gameId);
        });

        // Add click event listener for play buttons (direct launch)
        const playButton = cabinet.querySelector('.play-button');
        if (playButton) {
            playButton.addEventListener('click', function (e) {
                e.stopPropagation(); // Prevent cabinet click
                const gameId = cabinet.getAttribute('data-game');
                launchGame(gameId);
            });
        }

        // Add keyboard support
        cabinet.addEventListener('keydown', function (e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                const gameId = this.getAttribute('data-game');
                openGameModal(gameId);
            }
        });

        // Make cabinets focusable
        cabinet.setAttribute('tabindex', '0');
        cabinet.setAttribute('role', 'button');
        cabinet.setAttribute('aria-label', `Play ${gameData[cabinet.getAttribute('data-game')]?.title || 'game'}`);
    });
}

/**
 * Set up modal event listeners
 */
function setupModalListeners() {
    // Close modal buttons
    closeModalButtons.forEach(button => {
        button.addEventListener('click', closeGameModal);
    });

    // Modal play button click handler
    if (playLink) {
        playLink.addEventListener('click', function (e) {
            e.preventDefault(); // Prevent default link behavior
            const gameId = this.getAttribute('data-game-id');
            if (gameId) {
                launchGame(gameId);
                closeGameModal(); // Close modal after launching
            } else {
                // Fallback: open the href directly
                window.open(this.href, '_blank');
                closeGameModal();
            }
        });
    }

    // Close modal when clicking outside
    modal.addEventListener('click', function (e) {
        if (e.target === modal) {
            closeGameModal();
        }
    });

    // Close modal with Escape key
    document.addEventListener('keydown', function (e) {
        if (e.key === 'Escape' && modal.style.display === 'block') {
            closeGameModal();
        }
    });
}

/**
 * Set up neon effects and animations
 */
function setupNeonEffects() {
    // Add random neon color variations to titles
    const titles = document.querySelectorAll('.neon-title, .section-title');
    const neonColors = ['neon-glow', 'neon-glow-pink', 'neon-glow-green', 'neon-glow-purple'];
    const advancedEffects = ['neon-pulse-advanced', 'neon-flicker', 'neon-rainbow'];

    titles.forEach((title, index) => {
        const randomColor = neonColors[Math.floor(Math.random() * neonColors.length)];
        title.classList.add(randomColor);

        // Add advanced effects to some titles
        if (index % 3 === 0) {
            const randomAdvanced = advancedEffects[Math.floor(Math.random() * advancedEffects.length)];
            title.classList.add(randomAdvanced);
        }
    });

    // Add subtle animations to cabinets
    const cabinets = document.querySelectorAll('.arcade-cabinet');
    cabinets.forEach((cabinet, index) => {
        // Stagger the animation delays
        cabinet.style.animationDelay = `${index * 0.1}s`;
        cabinet.classList.add('cabinet-idle-animation');

        // Add random advanced effects to some cabinets
        if (index % 2 === 0) {
            cabinet.classList.add('cabinet-idle-glow');
        }
    });

    // Initialize cursor trail effect
    setupCursorTrail();

    // Initialize matrix particles
    setupMatrixParticles();
}

/**
 * Set up keyboard navigation
 */
function setupKeyboardNavigation() {
    // Add focus management for better accessibility
    document.addEventListener('keydown', function (e) {
        if (e.key === 'Tab') {
            // Add focus indicators
            const focusedElement = document.activeElement;
            if (focusedElement.classList.contains('arcade-cabinet')) {
                focusedElement.style.transform = 'translateY(-5px) scale(1.02)';
            }
        }
    });

    // Remove focus effects when element loses focus
    document.addEventListener('focusout', function (e) {
        if (e.target.classList.contains('arcade-cabinet')) {
            e.target.style.transform = '';
        }
    });
}

/**
 * Open game modal with game information
 * @param {string} gameId - The ID of the game to display
 */
function openGameModal(gameId) {
    const game = gameData[gameId];

    if (!game) {
        console.error('Game not found:', gameId);
        return;
    }

    // Update modal content
    modalTitle.textContent = game.title;
    modalDescription.textContent = game.description;
    modalImage.src = game.image;
    modalImage.alt = `${game.title} preview`;
    playLink.href = game.url;
    playLink.setAttribute('data-game-id', gameId); // Set game ID for modal play button

    // Update device label
    if (modalDeviceLabel && game.deviceType) {
        let labelText = '';
        switch (game.deviceType) {
            case 'mobile':
                labelText = 'Mobile';
                break;
            case 'desktop':
                labelText = 'Desktop';
                break;
            case 'both':
                labelText = 'Any Device';
                break;
            default:
                labelText = 'Desktop';
        }
        modalDeviceLabel.textContent = labelText;
        modalDeviceLabel.className = `device-label ${game.deviceType}`;
    }

    // Show modal
    modal.style.display = 'block';
    document.body.style.overflow = 'hidden';

    // Focus management
    const firstFocusable = modal.querySelector('button, a');
    if (firstFocusable) {
        firstFocusable.focus();
    }

    // Add entrance animation
    modal.classList.add('modal-enter');
}

/**
 * Close the game modal
 */
function closeGameModal() {
    modal.style.display = 'none';
    document.body.style.overflow = '';
    modal.classList.remove('modal-enter');
}

/**
 * Launch a game directly
 * @param {string} gameId - The ID of the game to launch
 */
function launchGame(gameId) {
    const game = gameData[gameId];

    if (!game) {
        console.error('Game not found:', gameId);
        return;
    }

    // Show loading state
    showGameLoadingState(game.title);

    // Launch the game in a new tab after a short delay for effect
    setTimeout(() => {
        window.open(game.url, '_blank');
        hideGameLoadingState();
    }, 500);
}

/**
 * Show game loading state
 * @param {string} gameTitle - The title of the game being loaded
 */
function showGameLoadingState(gameTitle) {
    const loadingOverlay = document.createElement('div');
    loadingOverlay.id = 'game-loading-overlay';
    loadingOverlay.innerHTML = `
        <div class="game-loading-content">
            <div class="game-loading-spinner"></div>
            <p class="game-loading-text">Launching ${gameTitle}...</p>
            <p class="game-loading-subtitle">Opening in new tab</p>
        </div>
    `;

    const style = document.createElement('style');
    style.textContent = `
        #game-loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
        }
        
        .game-loading-content {
            text-align: center;
            color: var(--neon-blue);
            padding: var(--spacing-lg);
            border: 2px solid var(--neon-blue);
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.8);
            box-shadow: var(--neon-shadow-blue);
        }
        
        .game-loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--neon-blue);
            border-top: 4px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        
        .game-loading-text {
            font-family: var(--font-primary);
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: var(--spacing-xs);
            text-shadow: var(--neon-shadow-blue);
        }
        
        .game-loading-subtitle {
            font-family: var(--font-secondary);
            font-size: 1rem;
            color: var(--neon-gray-light);
            margin: 0;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    `;

    document.head.appendChild(style);
    document.body.appendChild(loadingOverlay);
}

/**
 * Hide game loading state
 */
function hideGameLoadingState() {
    const loadingOverlay = document.getElementById('game-loading-overlay');
    if (loadingOverlay) {
        loadingOverlay.style.animation = 'fadeOut 0.3s ease-out';
        setTimeout(() => {
            loadingOverlay.remove();
        }, 300);
    }
}

/**
 * Add CSS animations dynamically
 */
function addDynamicStyles() {
    const style = document.createElement('style');
    style.textContent = `
    .cabinet-idle-animation {
      animation: cabinet-idle 4s ease-in-out infinite alternate;
    }
    
    @keyframes cabinet-idle {
      0% {
        filter: brightness(1);
      }
      100% {
        filter: brightness(1.1);
      }
    }
    
    .modal-enter .modal-content {
      animation: modal-enter 0.3s ease-out;
    }
    
    @keyframes modal-enter {
      from {
        opacity: 0;
        transform: scale(0.8) translateY(-50px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }
    
    /* Enhanced hover effects */
    .arcade-cabinet:hover .cabinet-screen {
      animation: cabinet-glow 0.6s ease-in-out infinite alternate;
    }
    
    @keyframes cabinet-glow {
      from {
        box-shadow: 0 0 5px var(--neon-blue), 0 0 10px var(--neon-blue), 0 0 15px var(--neon-blue);
      }
      to {
        box-shadow: 0 0 10px var(--neon-pink), 0 0 20px var(--neon-pink), 0 0 30px var(--neon-pink);
      }
    }
  `;
    document.head.appendChild(style);
}

// Add dynamic styles when script loads
addDynamicStyles();

// Performance optimization: Debounce scroll events
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Add scroll-based effects with parallax
const handleScroll = debounce(() => {
    const scrollTop = window.pageYOffset;
    const header = document.querySelector('.neon-header');

    if (header) {
        const headerHeight = header.offsetHeight;
        const opacity = Math.max(0, 1 - (scrollTop / headerHeight));
        header.style.opacity = opacity;
    }

    // Parallax effects for Tron grids
    const tronGrids = document.querySelectorAll('.tron-grid-advanced, .tron-grid-pulse');
    tronGrids.forEach((grid, index) => {
        const speed = 0.5 + (index * 0.2); // Different speeds for different layers
        const yPos = -(scrollTop * speed);
        grid.style.transform = `translateY(${yPos}px)`;
    });

    // Parallax for matrix particles
    const matrixParticles = document.querySelector('.matrix-particles');
    if (matrixParticles) {
        const yPos = -(scrollTop * 0.3);
        matrixParticles.style.transform = `translateY(${yPos}px)`;
    }

    // Parallax for regular grid
    const regularGrid = document.querySelector('.grid-background');
    if (regularGrid) {
        const yPos = -(scrollTop * 0.8);
        regularGrid.style.transform = `translateY(${yPos}px)`;
    }
}, 10);

window.addEventListener('scroll', handleScroll);

// Add loading state management
function showLoadingState() {
    const loadingOverlay = document.createElement('div');
    loadingOverlay.id = 'loading-overlay';
    loadingOverlay.innerHTML = `
    <div class="loading-content">
      <div class="loading-spinner"></div>
      <p class="loading-text">Loading Arcade...</p>
    </div>
  `;

    const style = document.createElement('style');
    style.textContent = `
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--neon-black);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    
    .loading-content {
      text-align: center;
      color: var(--neon-blue);
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 3px solid var(--neon-blue);
      border-top: 3px solid transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .loading-text {
      font-family: var(--font-primary);
      font-size: 1.2rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
  `;

    document.head.appendChild(style);
    document.body.appendChild(loadingOverlay);
}

function hideLoadingState() {
    const loadingOverlay = document.getElementById('loading-overlay');
    if (loadingOverlay) {
        loadingOverlay.remove();
    }
}

// Show loading state initially, hide when everything is ready
showLoadingState();

// Hide loading state when everything is loaded
window.addEventListener('load', () => {
    setTimeout(hideLoadingState, 1000); // Show loading for at least 1 second for effect
});

/**
 * Set up navigation functionality
 */
function setupNavigation() {
    const navToggle = document.querySelector('.nav-toggle');
    const navMenu = document.querySelector('.nav-menu');
    const navLinks = document.querySelectorAll('.nav-link');

    // Mobile menu toggle
    if (navToggle && navMenu) {
        navToggle.addEventListener('click', function () {
            navToggle.classList.toggle('active');
            navMenu.classList.toggle('active');
        });

        // Close menu when clicking on a link
        navLinks.forEach(link => {
            link.addEventListener('click', function () {
                navToggle.classList.remove('active');
                navMenu.classList.remove('active');
            });
        });

        // Close menu when clicking outside
        document.addEventListener('click', function (e) {
            if (!navToggle.contains(e.target) && !navMenu.contains(e.target)) {
                navToggle.classList.remove('active');
                navMenu.classList.remove('active');
            }
        });
    }

    // Active navigation highlighting
    window.addEventListener('scroll', debounce(() => {
        const sections = document.querySelectorAll('section[id]');
        const scrollPos = window.scrollY + 100;

        sections.forEach(section => {
            const sectionTop = section.offsetTop;
            const sectionHeight = section.offsetHeight;
            const sectionId = section.getAttribute('id');
            const navLink = document.querySelector(`.nav-link[href="#${sectionId}"]`);

            if (scrollPos >= sectionTop && scrollPos < sectionTop + sectionHeight) {
                navLinks.forEach(link => link.classList.remove('active'));
                if (navLink) navLink.classList.add('active');
            }
        });
    }, 10));
}

/**
 * Set up game filtering functionality
 */
function setupFiltering() {
    const filterButtons = document.querySelectorAll('.filter-btn');
    const cabinets = document.querySelectorAll('.arcade-cabinet');
    const grid = document.querySelector('.arcade-grid');

    filterButtons.forEach(button => {
        button.addEventListener('click', function () {
            const filter = this.getAttribute('data-filter');

            // Update active button
            filterButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');

            // Add filtered class to grid
            grid.classList.add('filtered');

            // Filter cabinets and reorganize
            let visibleCount = 0;
            cabinets.forEach(cabinet => {
                const category = cabinet.getAttribute('data-category');

                if (filter === 'all' || category === filter) {
                    cabinet.classList.remove('hidden');
                    cabinet.classList.add('visible');
                    visibleCount++;
                } else {
                    cabinet.classList.add('hidden');
                    cabinet.classList.remove('visible');
                }
            });

            // Update grid layout based on visible games
            if (visibleCount === 0) {
                grid.style.gridTemplateColumns = '1fr';
                grid.style.justifyContent = 'center';
            } else if (visibleCount === 1) {
                grid.style.gridTemplateColumns = '1fr';
                grid.style.justifyContent = 'center';
            } else if (visibleCount === 2) {
                grid.style.gridTemplateColumns = 'repeat(2, 1fr)';
                grid.style.justifyContent = 'center';
            } else {
                grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(300px, 1fr))';
                grid.style.justifyContent = 'start';
            }

            // Animate grid layout
            grid.style.opacity = '0.5';
            setTimeout(() => {
                grid.style.opacity = '1';
            }, 150);
        });
    });
}

/**
 * Set up smooth scrolling for navigation links
 */
function setupSmoothScrolling() {
    const navLinks = document.querySelectorAll('a[href^="#"]');
    const ctaButtons = document.querySelectorAll('.neon-button[href^="#"]');

    [...navLinks, ...ctaButtons].forEach(link => {
        link.addEventListener('click', function (e) {
            e.preventDefault();

            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);

            if (targetElement) {
                const headerHeight = document.querySelector('.neon-nav')?.offsetHeight || 0;
                const targetPosition = targetElement.offsetTop - headerHeight - 20;

                window.scrollTo({
                    top: targetPosition,
                    behavior: 'smooth'
                });
            }
        });
    });
}

/**
 * Add enhanced particle effects
 */
function createParticles() {
    const particlesContainer = document.querySelector('.particles-background');
    if (!particlesContainer) return;

    // Create multiple floating particles
    for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'floating-particle';
        particle.style.cssText = `
            position: absolute;
            width: ${Math.random() * 3 + 1}px;
            height: ${Math.random() * 3 + 1}px;
            background: var(--neon-blue);
            border-radius: 50%;
            left: ${Math.random() * 100}%;
            top: ${Math.random() * 100}%;
            opacity: ${Math.random() * 0.5 + 0.3};
            animation: float-particle ${Math.random() * 10 + 5}s ease-in-out infinite;
            animation-delay: ${Math.random() * 5}s;
        `;
        particlesContainer.appendChild(particle);
    }

    // Add particle animation CSS
    const style = document.createElement('style');
    style.textContent = `
        @keyframes float-particle {
            0%, 100% {
                transform: translateY(0px) translateX(0px) scale(1);
                opacity: 0.3;
            }
            25% {
                transform: translateY(-20px) translateX(10px) scale(1.2);
                opacity: 0.8;
            }
            50% {
                transform: translateY(-10px) translateX(-5px) scale(0.8);
                opacity: 0.5;
            }
            75% {
                transform: translateY(-30px) translateX(15px) scale(1.1);
                opacity: 0.7;
            }
        }
    `;
    document.head.appendChild(style);
}

// Initialize particles after DOM is loaded
document.addEventListener('DOMContentLoaded', function () {
    setTimeout(createParticles, 1000);
});

/**
 * Set up cursor trail effect
 */
function setupCursorTrail() {
    let mouseX = 0;
    let mouseY = 0;
    let trailElements = [];

    document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;

        // Create trail element
        const trail = document.createElement('div');
        trail.className = 'cursor-trail';
        trail.style.left = mouseX + 'px';
        trail.style.top = mouseY + 'px';

        // Randomize trail color
        const colors = ['var(--neon-blue)', 'var(--neon-pink)', 'var(--neon-green)', 'var(--neon-purple)'];
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        trail.style.background = `radial-gradient(circle, ${randomColor}, transparent)`;

        document.body.appendChild(trail);
        trailElements.push(trail);

        // Remove trail after animation
        setTimeout(() => {
            if (trail.parentNode) {
                trail.parentNode.removeChild(trail);
            }
            trailElements = trailElements.filter(el => el !== trail);
        }, 500);

        // Limit number of trail elements
        if (trailElements.length > 10) {
            const oldTrail = trailElements.shift();
            if (oldTrail && oldTrail.parentNode) {
                oldTrail.parentNode.removeChild(oldTrail);
            }
        }
    });
}

/**
 * Set up matrix-style particle background
 */
function setupMatrixParticles() {
    const matrixContainer = document.querySelector('.matrix-particles');
    if (!matrixContainer) return;

    const characters = '01ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒŽãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒžãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ²ãƒ³';
    const numbers = '0123456789';
    const allChars = characters + numbers;

    function createMatrixParticle() {
        const particle = document.createElement('div');
        particle.className = 'matrix-particle';
        particle.textContent = allChars[Math.floor(Math.random() * allChars.length)];

        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDuration = (Math.random() * 5 + 5) + 's';
        particle.style.animationDelay = Math.random() * 2 + 's';

        // Random color
        const colors = ['var(--neon-green)', 'var(--neon-blue)', 'var(--neon-pink)'];
        particle.style.color = colors[Math.floor(Math.random() * colors.length)];

        matrixContainer.appendChild(particle);

        // Remove particle after animation
        setTimeout(() => {
            if (particle.parentNode) {
                particle.parentNode.removeChild(particle);
            }
        }, 10000);
    }

    // Create particles periodically
    setInterval(createMatrixParticle, 200);

    // Create initial particles
    for (let i = 0; i < 20; i++) {
        setTimeout(createMatrixParticle, i * 100);
    }
}

/**
 * Enhanced cabinet interactions
 */
function setupEnhancedCabinetInteractions() {
    const cabinets = document.querySelectorAll('.arcade-cabinet');
    let selectedCabinet = null;

    cabinets.forEach(cabinet => {
        // Add selection state
        cabinet.addEventListener('click', function (e) {
            if (e.target.classList.contains('play-button')) {
                return; // Don't select if clicking play button
            }

            // Remove previous selection
            if (selectedCabinet) {
                selectedCabinet.classList.remove('selected');
                selectedCabinet.classList.remove('cabinet-selected');
            }

            // Add selection to current cabinet
            this.classList.add('selected');
            this.classList.add('cabinet-selected');
            selectedCabinet = this;

            // Remove selection after animation
            setTimeout(() => {
                this.classList.remove('cabinet-selected');
            }, 500);
        });

        // Add loading state for play buttons
        const playButton = cabinet.querySelector('.play-button');
        if (playButton) {
            playButton.addEventListener('click', function () {
                const cabinet = this.closest('.arcade-cabinet');
                cabinet.classList.add('cabinet-loading');

                // Remove loading state after game launch
                setTimeout(() => {
                    cabinet.classList.remove('cabinet-loading');
                }, 1000);
            });
        }
    });
}

// Initialize enhanced interactions
document.addEventListener('DOMContentLoaded', function () {
    setTimeout(setupEnhancedCabinetInteractions, 1000);
    setTimeout(setupSoundEffects, 2000);
});

/**
 * Set up optional arcade sound effects
 */
function setupSoundEffects() {
    // Check if user prefers reduced motion or has disabled audio
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        return; // Skip sound effects for accessibility
    }

    let audioContext = null;
    let soundEnabled = false;

    // Initialize Web Audio API
    function initAudio() {
        if (!audioContext) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                soundEnabled = true;
                console.log('Arcade sound effects enabled');
            } catch (e) {
                console.log('Web Audio API not supported');
                return;
            }
        }
    }

    // Create sound effects using Web Audio API
    function createBeep(frequency = 800, duration = 0.1, type = 'sine') {
        if (!soundEnabled || !audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }

    function createArcadeClick() {
        createBeep(1000, 0.05, 'square');
    }

    function createArcadeHover() {
        createBeep(1200, 0.08, 'sine');
    }

    function createGameLaunch() {
        // Create a sequence of beeps for game launch
        createBeep(800, 0.1, 'sine');
        setTimeout(() => createBeep(1000, 0.1, 'sine'), 100);
        setTimeout(() => createBeep(1200, 0.1, 'sine'), 200);
    }

    function createModalOpen() {
        createBeep(600, 0.15, 'triangle');
    }

    function createModalClose() {
        createBeep(400, 0.15, 'triangle');
    }

    // Add sound effects to interactions
    function addSoundToElements() {
        // Cabinet hover sounds
        const cabinets = document.querySelectorAll('.arcade-cabinet');
        cabinets.forEach(cabinet => {
            cabinet.addEventListener('mouseenter', () => {
                if (soundEnabled) createArcadeHover();
            });
        });

        // Play button click sounds
        const playButtons = document.querySelectorAll('.play-button');
        playButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (soundEnabled) createGameLaunch();
            });
        });

        // Filter button sounds
        const filterButtons = document.querySelectorAll('.filter-btn');
        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (soundEnabled) createArcadeClick();
            });
        });

        // Navigation link sounds
        const navLinks = document.querySelectorAll('.nav-link');
        navLinks.forEach(link => {
            link.addEventListener('click', () => {
                if (soundEnabled) createArcadeClick();
            });
        });
    }

    // Add sound to modal interactions
    function addModalSounds() {
        const modal = document.getElementById('game-modal');
        if (modal) {
            // Override modal functions to add sounds
            const originalOpenModal = window.NeonArcade.openGameModal;
            const originalCloseModal = window.NeonArcade.closeGameModal;

            window.NeonArcade.openGameModal = function (gameId) {
                if (soundEnabled) createModalOpen();
                return originalOpenModal.call(this, gameId);
            };

            window.NeonArcade.closeGameModal = function () {
                if (soundEnabled) createModalClose();
                return originalCloseModal.call(this);
            };
        }
    }

    // Create sound toggle button
    function createSoundToggle() {
        const soundToggle = document.createElement('button');
        soundToggle.id = 'sound-toggle';
        soundToggle.innerHTML = 'ðŸ”Š';
        soundToggle.title = 'Toggle Sound Effects';
        soundToggle.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid var(--neon-blue);
            background: rgba(0, 0, 0, 0.8);
            color: var(--neon-blue);
            font-size: 20px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
        `;

        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggle.innerHTML = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
            soundToggle.style.color = soundEnabled ? 'var(--neon-blue)' : 'var(--neon-gray)';
            soundToggle.style.borderColor = soundEnabled ? 'var(--neon-blue)' : 'var(--neon-gray)';

            if (soundEnabled && !audioContext) {
                initAudio();
            }
        });

        soundToggle.addEventListener('mouseenter', () => {
            soundToggle.style.boxShadow = '0 0 20px var(--neon-blue)';
        });

        soundToggle.addEventListener('mouseleave', () => {
            soundToggle.style.boxShadow = 'none';
        });

        document.body.appendChild(soundToggle);
    }

    // Initialize everything
    createSoundToggle();

    // Initialize audio on first user interaction
    document.addEventListener('click', () => {
        if (!audioContext) {
            initAudio();
            addSoundToElements();
            addModalSounds();
        }
    }, { once: true });
}

// Export functions for potential external use
window.NeonArcade = {
    openGameModal,
    closeGameModal,
    launchGame,
    gameData,
    setupFiltering,
    setupNavigation,
    setupCursorTrail,
    setupMatrixParticles,
    setupEnhancedCabinetInteractions,
    setupSoundEffects
};
